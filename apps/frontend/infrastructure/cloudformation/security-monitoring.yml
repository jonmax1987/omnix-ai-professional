AWSTemplateFormatVersion: '2010-09-09'
Description: 'OMNIX AI - Security Monitoring & Anomaly Detection'

Parameters:
  Environment:
    Type: String
    Default: staging
    AllowedValues: [staging, production]
    Description: Environment name

  ProjectName:
    Type: String
    Default: omnix-ai
    Description: Project name for resource naming

  AlertTopicArn:
    Type: String
    Description: SNS Topic ARN for security alerts

  ApiGatewayId:
    Type: String
    Description: API Gateway ID to monitor

  CloudTrailLogGroupName:
    Type: String
    Description: CloudTrail log group name
    Default: /aws/cloudtrail/omnix-ai

Resources:
  # Security Monitoring Lambda
  SecurityMonitorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${Environment}-security-monitor'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt SecurityMonitorRole.Arn
      Timeout: 300
      Environment:
        Variables:
          API_GATEWAY_ID: !Ref ApiGatewayId
          ALERT_TOPIC_ARN: !Ref AlertTopicArn
          ENVIRONMENT: !Ref Environment
          PROJECT_NAME: !Ref ProjectName
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import re
          from datetime import datetime, timedelta
          from collections import defaultdict

          cloudwatch = boto3.client('cloudwatch')
          logs = boto3.client('logs')
          sns = boto3.client('sns')

          # PII patterns to detect
          PII_PATTERNS = {
              'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
              'ssn': r'\b\d{3}-?\d{2}-?\d{4}\b',
              'credit_card': r'\b(?:\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4})\b',
              'phone': r'\b\d{3}[-.]\d{3}[-.]\d{4}\b',
              'api_key': r'(?i)(api[_-]?key|token|secret)["\s]*[:=]["\s]*([a-zA-Z0-9_-]{16,})',
              'aws_key': r'AKIA[0-9A-Z]{16}'
          }

          def lambda_handler(event, context):
              try:
                  results = {
                      'timestamp': datetime.now().isoformat(),
                      'security_checks': {}
                  }
                  
                  # 1. Check for PII exposure in logs
                  pii_results = check_pii_exposure()
                  results['security_checks']['pii_exposure'] = pii_results
                  
                  # 2. Monitor authentication failure rates
                  auth_results = monitor_authentication_failures()
                  results['security_checks']['authentication'] = auth_results
                  
                  # 3. Check security headers compliance
                  headers_results = check_security_headers()
                  results['security_checks']['security_headers'] = headers_results
                  
                  # 4. Detect anomalous access patterns
                  anomaly_results = detect_access_anomalies()
                  results['security_checks']['access_anomalies'] = anomaly_results
                  
                  # 5. Monitor error rates for potential attacks
                  error_results = monitor_error_rates()
                  results['security_checks']['error_monitoring'] = error_results
                  
                  # Send alerts for critical security issues
                  critical_issues = []
                  for check_name, check_result in results['security_checks'].items():
                      if check_result.get('critical', False):
                          critical_issues.append(f"{check_name}: {check_result.get('message', 'Critical issue detected')}")
                  
                  if critical_issues:
                      send_security_alert('Critical Security Issues Detected', {
                          'issues': critical_issues,
                          'details': results
                      })
                  
                  # Publish security metrics
                  publish_security_metrics(results)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(results, indent=2)
                  }
                  
              except Exception as e:
                  error_result = {
                      'timestamp': datetime.now().isoformat(),
                      'error': str(e)
                  }
                  
                  send_security_alert('Security Monitoring System Error', error_result)
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps(error_result)
                  }

          def check_pii_exposure():
              try:
                  # Check application logs for PII patterns
                  log_group_names = [
                      f'/aws/lambda/{os.environ["PROJECT_NAME"]}-{os.environ["ENVIRONMENT"]}-*',
                      f'/aws/apigateway/{os.environ["API_GATEWAY_ID"]}'
                  ]
                  
                  pii_violations = []
                  end_time = datetime.now()
                  start_time = end_time - timedelta(hours=1)
                  
                  for pattern_name, pattern in PII_PATTERNS.items():
                      try:
                          response = logs.start_query(
                              logGroupName=log_group_names[0],
                              startTime=int(start_time.timestamp()),
                              endTime=int(end_time.timestamp()),
                              queryString=f'fields @timestamp, @message | filter @message like /{pattern}/ | limit 10'
                          )
                          
                          query_id = response['queryId']
                          
                          # Wait for query completion
                          import time
                          time.sleep(2)
                          
                          results = logs.get_query_results(queryId=query_id)
                          
                          if results['results']:
                              pii_violations.append({
                                  'pattern': pattern_name,
                                  'count': len(results['results']),
                                  'samples': [r[1]['value'][:100] + '...' for r in results['results'][:3]]
                              })
                              
                      except Exception as e:
                          print(f"Error checking PII pattern {pattern_name}: {e}")
                  
                  return {
                      'critical': len(pii_violations) > 0,
                      'violations': pii_violations,
                      'message': f'Found {len(pii_violations)} PII pattern violations'
                  }
                  
              except Exception as e:
                  return {
                      'critical': False,
                      'error': str(e),
                      'message': 'PII check failed'
                  }

          def monitor_authentication_failures():
              try:
                  end_time = datetime.now()
                  start_time = end_time - timedelta(minutes=30)
                  
                  # Get 4XX error count from API Gateway
                  response = cloudwatch.get_metric_statistics(
                      Namespace='AWS/ApiGateway',
                      MetricName='4XXError',
                      Dimensions=[
                          {
                              'Name': 'ApiName',
                              'Value': os.environ['API_GATEWAY_ID']
                          }
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=300,
                      Statistics=['Sum']
                  )
                  
                  total_4xx = sum(dp['Sum'] for dp in response['Datapoints'])
                  
                  # Alert if more than 50 4XX errors in 30 minutes
                  is_critical = total_4xx > 50
                  
                  return {
                      'critical': is_critical,
                      'error_count': total_4xx,
                      'message': f'{total_4xx} authentication/authorization failures in last 30 minutes'
                  }
                  
              except Exception as e:
                  return {
                      'critical': False,
                      'error': str(e),
                      'message': 'Authentication monitoring failed'
                  }

          def check_security_headers():
              try:
                  # This would typically check via synthetic testing
                  # For now, we'll create a placeholder that can be expanded
                  
                  # Mock security header check
                  required_headers = [
                      'Content-Security-Policy',
                      'X-Frame-Options',
                      'X-Content-Type-Options',
                      'Strict-Transport-Security'
                  ]
                  
                  # In a real implementation, this would make HTTP requests
                  # and check response headers
                  missing_headers = []  # Placeholder
                  
                  return {
                      'critical': len(missing_headers) > 2,
                      'missing_headers': missing_headers,
                      'message': f'{len(missing_headers)} security headers missing'
                  }
                  
              except Exception as e:
                  return {
                      'critical': False,
                      'error': str(e),
                      'message': 'Security headers check failed'
                  }

          def detect_access_anomalies():
              try:
                  end_time = datetime.now()
                  start_time = end_time - timedelta(hours=1)
                  
                  # Get request count from API Gateway
                  response = cloudwatch.get_metric_statistics(
                      Namespace='AWS/ApiGateway',
                      MetricName='Count',
                      Dimensions=[
                          {
                              'Name': 'ApiName',
                              'Value': os.environ['API_GATEWAY_ID']
                          }
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=300,
                      Statistics=['Sum']
                  )
                  
                  if not response['Datapoints']:
                      return {
                          'critical': False,
                          'message': 'No data available for anomaly detection'
                      }
                  
                  request_counts = [dp['Sum'] for dp in response['Datapoints']]
                  avg_requests = sum(request_counts) / len(request_counts)
                  max_requests = max(request_counts)
                  
                  # Simple anomaly detection: if any 5-minute period has 10x the average
                  is_anomalous = max_requests > (avg_requests * 10) if avg_requests > 0 else False
                  
                  return {
                      'critical': is_anomalous,
                      'average_requests': avg_requests,
                      'max_requests': max_requests,
                      'message': f'Peak traffic: {max_requests} requests vs {avg_requests:.1f} average'
                  }
                  
              except Exception as e:
                  return {
                      'critical': False,
                      'error': str(e),
                      'message': 'Anomaly detection failed'
                  }

          def monitor_error_rates():
              try:
                  end_time = datetime.now()
                  start_time = end_time - timedelta(minutes=30)
                  
                  # Get 5XX error count
                  response = cloudwatch.get_metric_statistics(
                      Namespace='AWS/ApiGateway',
                      MetricName='5XXError',
                      Dimensions=[
                          {
                              'Name': 'ApiName',
                              'Value': os.environ['API_GATEWAY_ID']
                          }
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=300,
                      Statistics=['Sum']
                  )
                  
                  total_5xx = sum(dp['Sum'] for dp in response['Datapoints'])
                  
                  # Alert if more than 10 5XX errors in 30 minutes
                  is_critical = total_5xx > 10
                  
                  return {
                      'critical': is_critical,
                      'error_count': total_5xx,
                      'message': f'{total_5xx} server errors in last 30 minutes'
                  }
                  
              except Exception as e:
                  return {
                      'critical': False,
                      'error': str(e),
                      'message': 'Error rate monitoring failed'
                  }

          def send_security_alert(subject, details):
              try:
                  sns.publish(
                      TopicArn=os.environ['ALERT_TOPIC_ARN'],
                      Subject=f'OMNIX AI SECURITY ALERT: {subject}',
                      Message=json.dumps(details, indent=2, default=str)
                  )
              except Exception as e:
                  print(f"Failed to send security alert: {e}")

          def publish_security_metrics(results):
              try:
                  namespace = 'OMNIX/Security'
                  
                  for check_name, check_result in results['security_checks'].items():
                      # Publish security check status
                      cloudwatch.put_metric_data(
                          Namespace=namespace,
                          MetricData=[
                              {
                                  'MetricName': 'SecurityCheckStatus',
                                  'Value': 0 if check_result.get('critical', False) else 1,
                                  'Unit': 'Count',
                                  'Dimensions': [
                                      {
                                          'Name': 'Check',
                                          'Value': check_name
                                      }
                                  ],
                                  'Timestamp': datetime.now()
                              }
                          ]
                      )
                      
                      # Publish specific metrics
                      if check_name == 'pii_exposure' and 'violations' in check_result:
                          cloudwatch.put_metric_data(
                              Namespace=namespace,
                              MetricData=[
                                  {
                                      'MetricName': 'PIIViolations',
                                      'Value': len(check_result['violations']),
                                      'Unit': 'Count',
                                      'Timestamp': datetime.now()
                                  }
                              ]
                          )
                      
                      elif check_name == 'authentication' and 'error_count' in check_result:
                          cloudwatch.put_metric_data(
                              Namespace=namespace,
                              MetricData=[
                                  {
                                      'MetricName': 'AuthenticationFailures',
                                      'Value': check_result['error_count'],
                                      'Unit': 'Count',
                                      'Timestamp': datetime.now()
                                  }
                              ]
                          )
                  
              except Exception as e:
                  print(f"Failed to publish security metrics: {e}")

  # IAM Role for Security Monitor
  SecurityMonitorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-security-monitor-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SecurityMonitorPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudwatch:GetMetricStatistics
                  - cloudwatch:PutMetricData
                  - logs:StartQuery
                  - logs:GetQueryResults
                  - logs:DescribeLogGroups
                  - sns:Publish
                Resource: '*'

  # Security Monitor Schedule (every 15 minutes)
  SecurityMonitorSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-security-monitor-schedule'
      Description: 'Schedule for security monitoring'
      ScheduleExpression: 'rate(15 minutes)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt SecurityMonitorFunction.Arn
          Id: 'SecurityMonitorTarget'

  # Lambda Permission for Security Monitor
  SecurityMonitorPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SecurityMonitorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt SecurityMonitorSchedule.Arn

  # Security Alarms
  PIIExposureAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${Environment}-pii-exposure'
      AlarmDescription: 'PII exposure detected in logs'
      MetricName: PIIViolations
      Namespace: OMNIX/Security
      Statistic: Sum
      Period: 900
      EvaluationPeriods: 1
      Threshold: 0
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref AlertTopicArn
      TreatMissingData: notBreaching

  AuthenticationFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${Environment}-auth-failures'
      AlarmDescription: 'High authentication failure rate'
      MetricName: AuthenticationFailures
      Namespace: OMNIX/Security
      Statistic: Sum
      Period: 1800
      EvaluationPeriods: 1
      Threshold: 100
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref AlertTopicArn
      TreatMissingData: notBreaching

  # Security Dashboard
  SecurityDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub '${ProjectName}-${Environment}-security'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 24,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "OMNIX/Security", "SecurityCheckStatus", "Check", "pii_exposure", { "label": "PII Exposure Check" } ],
                  [ ".", ".", ".", "authentication", { "label": "Authentication Check" } ],
                  [ ".", ".", ".", "security_headers", { "label": "Security Headers Check" } ],
                  [ ".", ".", ".", "access_anomalies", { "label": "Access Anomaly Check" } ],
                  [ ".", ".", ".", "error_monitoring", { "label": "Error Monitoring Check" } ]
                ],
                "view": "timeSeries",
                "stacked": false,
                "region": "${AWS::Region}",
                "title": "Security Check Status (1 = Pass, 0 = Fail)",
                "period": 900,
                "stat": "Maximum"
              }
            },
            {
              "type": "metric",
              "x": 0,
              "y": 6,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "OMNIX/Security", "PIIViolations" ],
                  [ ".", "AuthenticationFailures" ]
                ],
                "view": "timeSeries",
                "stacked": false,
                "region": "${AWS::Region}",
                "title": "Security Violations",
                "period": 900,
                "stat": "Sum"
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 6,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  [ "AWS/ApiGateway", "4XXError", "ApiName", "${ApiGatewayId}" ],
                  [ ".", "5XXError", ".", "." ]
                ],
                "view": "timeSeries",
                "stacked": false,
                "region": "${AWS::Region}",
                "title": "API Gateway Errors",
                "period": 300,
                "stat": "Sum"
              }
            }
          ]
        }

Outputs:
  SecurityDashboardURL:
    Description: 'Security Monitoring Dashboard URL'
    Value: !Sub 'https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${ProjectName}-${Environment}-security'
    Export:
      Name: !Sub '${AWS::StackName}-SecurityDashboardURL'

  SecurityMonitorFunctionArn:
    Description: 'Security Monitor Lambda Function ARN'
    Value: !GetAtt SecurityMonitorFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-SecurityMonitorFunctionArn'